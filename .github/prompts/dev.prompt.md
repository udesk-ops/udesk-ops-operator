# udesk-ops-operator Development Prompt

You are an AI assistant helping with the development of **udesk-ops-operator**, a production-grade Kubernetes Operator that provides intelligent scaling management with approval workflows and multi-channel notification systems.

## Project Overview

**udesk-ops-operator** is a Go-based Kubernetes Operator built with:
- **Framework**: Kubebuilder/controller-runtime
- **Language**: Go 1.24+
- **Testing**: Ginkgo v2 BDD framework exclusively
- **API**: REST API server for external integrations
- **CRDs**: AlertScale, ScaleNotifyConfig, ScaleNotifyMsgTemplate

## 🔧 Kubebuilder Framework

This project is built using **Kubebuilder v4**, a framework for building Kubernetes APIs using Custom Resource Definitions (CRDs). Kubebuilder provides:

### Core Components
- **controller-runtime**: Core controller framework for building operators
- **Code Generation**: Automatic generation of CRD manifests, RBAC, and deep copy methods
- **Webhook Framework**: Admission and conversion webhook scaffolding
- **Testing Framework**: Integration with envtest for realistic testing
- **Project Scaffolding**: Standardized project structure and boilerplate

### Kubebuilder Project Structure
```
PROJECT                       # Kubebuilder project configuration
├── Dockerfile               # Multi-stage container build
├── Makefile                 # Generated build and development targets
├── go.mod & go.sum         # Go module dependencies
├── api/v1beta1/            # CRD type definitions
│   ├── *_types.go          # Custom resource struct definitions
│   └── zz_generated.*.go   # Generated code (deepcopy, etc.)
├── bin/                    # Generated development tools
│   ├── controller-gen      # CRD and RBAC manifest generator
│   ├── kustomize          # Kubernetes configuration tool
│   └── setup-envtest      # Test environment setup
├── config/                 # Kubernetes deployment manifests
│   ├── crd/bases/         # Generated CRD definitions
│   ├── rbac/              # Generated RBAC manifests
│   ├── manager/           # Operator deployment configuration
│   ├── default/           # Default kustomization
│   └── samples/           # Example custom resources
├── internal/controller/    # Controller reconciliation logic
└── cmd/main.go            # Operator entrypoint with manager setup
```

### Generated Makefile Targets
```bash
# Development workflow (generated by Kubebuilder)
make manifests              # Generate CRD, RBAC manifests
make generate              # Generate deepcopy and other code
make fmt                   # Format Go code
make vet                   # Run go vet static analysis
make test                  # Run Ginkgo tests with envtest
make lint                  # Run golangci-lint

# Deployment targets
make build                 # Build operator binary
make docker-build         # Build container image
make docker-push          # Push to registry
make deploy               # Deploy to current kubectl context
make undeploy             # Remove from cluster
make install              # Install CRDs only
make uninstall            # Remove CRDs

# Local development
make run                  # Run operator locally (no webhooks)
```

### Kubebuilder Annotations and Markers
Kubebuilder uses Go comments (markers) to generate manifests:

#### CRD Markers
```go
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Namespaced
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.phase"
// +kubebuilder:validation:Required
// +kubebuilder:validation:Minimum=1
// +kubebuilder:validation:Maximum=100
// +kubebuilder:default:="default-value"
```

#### RBAC Markers
```go
// +kubebuilder:rbac:groups=ops.udesk.cn,resources=alertscales,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ops.udesk.cn,resources=alertscales/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;update;patch
// +kubebuilder:rbac:groups="",resources=pods,verbs=get;list;watch
```

#### Webhook Markers
```go
// +kubebuilder:webhook:path=/mutate-ops-udesk-cn-v1beta1-alertscale,mutating=true,failurePolicy=fail,sideEffects=None,groups=ops.udesk.cn,resources=alertscales,verbs=create;update,versions=v1beta1,name=malertscale.kb.io,admissionReviewVersions=v1
// +kubebuilder:webhook:path=/validate-ops-udesk-cn-v1beta1-alertscale,mutating=false,failurePolicy=fail,sideEffects=None,groups=ops.udesk.cn,resources=alertscales,verbs=create;update,versions=v1beta1,name=valertscale.kb.io,admissionReviewVersions=v1
```

## 🚨 MANDATORY REQUIREMENTS

### Code Quality Gates (NON-NEGOTIABLE)
Every code change MUST complete ALL of these steps before being considered done:

1. **Add Test Cases**: Write comprehensive Ginkgo tests for new functionality
2. **Execute Tests**: Run `make test` and ensure 100% pass rate
3. **Execute Linting**: Run `make lint` and achieve 0 issues
4. **NO EXCEPTIONS**: All three steps must succeed with zero errors/failures

### Documentation Standards
- **ALL documentation** files go in the `docs/` directory
- **Project overview** is maintained in root `README.md`
- **API docs** → `docs/api/`
- **Development guides** → `docs/development/`
- **Deployment guides** → `docs/deployment/`
- **Architecture docs** → `docs/architecture/`

### Testing Framework Requirements
- **ONLY Ginkgo v2 BDD**: No standard Go testing allowed
- **Test Structure**: Each package requires `*_suite_test.go` + `*_test.go`
- **Coverage**: Meaningful test coverage for all new functionality
- **BDD Style**: Use descriptive, behavior-driven test specifications

## 📁 Project Architecture

```
udesk-ops-operator/
├── api/v1beta1/              # Custom Resource Definitions
│   ├── alertscale_types.go
│   ├── scalenotifyconfig_types.go
│   └── scalenotifymsgtemplate_types.go
├── cmd/
│   └── main.go               # Application entry point
├── config/                   # Kubernetes manifests
│   ├── crd/                  # CRD definitions
│   ├── rbac/                 # RBAC configurations
│   ├── manager/              # Deployment configs
│   └── samples/              # Example resources
├── docs/                     # ALL documentation (REQUIRED)
│   ├── api/                  # API documentation
│   ├── architecture/         # Architecture diagrams
│   ├── deployment/           # Installation guides
│   └── development/          # Development guides
├── internal/
│   ├── controller/           # Kubernetes controllers
│   │   ├── alertscale_controller.go
│   │   ├── scalenotifyconfig_controller.go
│   │   └── scalenotifymsgtemplate_controller.go
│   ├── handler/              # State machine handlers
│   │   └── scale_state_handler.go
│   ├── server/               # REST API server
│   │   ├── server.go
│   │   └── handlers/         # HTTP endpoint handlers
│   ├── strategy/             # Scaling strategies
│   │   ├── scale_strategy.go
│   │   └── notify_strategy.go
│   ├── types/                # Internal type definitions
│   │   └── scale_types.go
│   └── webhook/              # Admission webhooks
│       └── v1beta1/
├── test/                     # Integration and E2E tests
│   ├── e2e/                  # End-to-end tests
│   └── utils/                # Test utilities
└── README.md                 # Project overview
```

## 🏗️ Development Guidelines

### Kubebuilder Development Workflow

#### Adding New Custom Resource Definition (CRD)
```bash
# 1. Create API and Controller scaffolding
kubebuilder create api --group ops --version v1beta1 --kind PodRebalance --resource --controller

# 2. Edit the generated types file (api/v1beta1/podrebalance_types.go)
# - Define Spec and Status structures
# - Add validation markers
# - Add print columns markers

# 3. Generate manifests and code
make manifests generate

# 4. Implement controller logic (internal/controller/podrebalance_controller.go)
# - Implement Reconcile function
# - Add RBAC markers
# - Handle finalizers and status updates

# 5. Add comprehensive Ginkgo tests
# - Create controller_suite_test.go if not exists
# - Add reconciliation test scenarios
# - Test all state transitions

# 6. Verify implementation
make test lint
```

#### Adding Webhook Validation
```bash
# 1. Create webhook scaffolding
kubebuilder create webhook --group ops --version v1beta1 --kind AlertScale --defaulting --programmatic-validation

# 2. Implement webhook logic (api/v1beta1/alertscale_webhook.go)
# - Add Default() method for setting defaults
# - Add ValidateCreate/Update/Delete methods
# - Add webhook markers

# 3. Generate webhook manifests
make manifests

# 4. Test webhook functionality
make test
```

#### Kubebuilder Code Generation Commands
```bash
# Generate CRD manifests, RBAC, and other Kubernetes resources
make manifests

# Generate deepcopy methods and other boilerplate code  
make generate

# Both commands use controller-gen tool with these markers:
# manifests: generates config/crd/bases/*.yaml, config/rbac/role.yaml
# object: generates zz_generated.deepcopy.go files
```

#### Working with Kubebuilder Markers

**CRD Schema Validation**
```go
type AlertScaleSpec struct {
    // +kubebuilder:validation:Required
    // +kubebuilder:validation:Minimum=1
    // +kubebuilder:validation:Maximum=1000
    Replicas int32 `json:"replicas"`
    
    // +kubebuilder:validation:Optional
    // +kubebuilder:default:="5m"
    // +kubebuilder:validation:Pattern=`^[0-9]+(s|m|h)$`
    Timeout string `json:"timeout,omitempty"`
    
    // +kubebuilder:validation:Enum=Deployment;StatefulSet;DaemonSet
    TargetType string `json:"targetType"`
}
```

**Status Subresource and Print Columns**
```go
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Namespaced,shortName=as
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.phase"
// +kubebuilder:printcolumn:name="Replicas",type="integer",JSONPath=".spec.replicas" 
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
type AlertScale struct {
    metav1.TypeMeta   `json:",inline"`
    metav1.ObjectMeta `json:"metadata,omitempty"`

    Spec   AlertScaleSpec   `json:"spec,omitempty"`
    Status AlertScaleStatus `json:"status,omitempty"`
}
```

**RBAC Generation**
```go
// AlertScaleReconciler reconciles a AlertScale object
type AlertScaleReconciler struct {
    client.Client
    Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=ops.udesk.cn,resources=alertscales,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ops.udesk.cn,resources=alertscales/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=ops.udesk.cn,resources=alertscales/finalizers,verbs=update
// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;update;patch
// +kubebuilder:rbac:groups="",resources=events,verbs=create;patch

func (r *AlertScaleReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    // Implementation
}
```

### Kubernetes Operator Best Practices

#### Controller Development
- **Reconciliation**: Implement idempotent reconcile loops
- **Error Handling**: Use controller-runtime error patterns
- **Status Updates**: Always use separate status client
- **Finalizers**: Implement proper cleanup mechanisms
- **Events**: Record meaningful Kubernetes events
- **Metrics**: Add Prometheus metrics for observability

#### CRD Design Principles
- **Validation**: Use OpenAPI schema validation
- **Status Subresource**: Always implement status reporting
- **Conditions**: Use standard Kubernetes condition types
- **Defaults**: Set sensible default values
- **Immutability**: Mark appropriate fields as immutable

#### State Management
- **State Machine**: Use clear state transitions
- **Status Reporting**: Provide detailed status information
- **Error Recovery**: Implement robust error recovery
- **Timeout Handling**: Set appropriate timeouts

### API Server Best Practices

#### REST API Design
- **Versioning**: Use `/api/v1/` prefix
- **HTTP Methods**: Follow RESTful conventions
- **Status Codes**: Use appropriate HTTP status codes
- **Error Responses**: Return consistent error formats
- **Authentication**: Implement proper auth for production

#### Handler Implementation
- **Input Validation**: Validate all input parameters
- **Context Propagation**: Pass context for cancellation
- **Logging**: Log all operations with structured logging
- **Error Handling**: Return meaningful error messages
- **Rate Limiting**: Consider rate limiting for production

### Code Quality Standards

#### Go Language Standards
```go
// Package imports organization
import (
    // Standard library
    "context"
    "fmt"
    "time"

    // Third-party packages
    "github.com/go-logr/logr"
    "k8s.io/api/apps/v1"
    "sigs.k8s.io/controller-runtime"

    // Internal packages
    "udesk.cn/ops/api/v1beta1"
    "udesk.cn/ops/internal/types"
)
```

#### Error Handling Patterns
```go
// Controller error handling
if err != nil {
    log.Error(err, "Failed to perform operation", "resource", req.NamespacedName)
    return ctrl.Result{RequeueAfter: time.Minute * 5}, err
}

// API handler error handling
if err != nil {
    http.Error(w, fmt.Sprintf("Internal server error: %v", err), http.StatusInternalServerError)
    return
}
```

#### Logging Standards
```go
// Use structured logging
log := ctrl.Log.WithName("alertscale-controller")
log.Info("Reconciling AlertScale", 
    "namespace", alertScale.Namespace,
    "name", alertScale.Name,
    "generation", alertScale.Generation)
```

## 🧪 Testing Requirements

### Ginkgo Test Structure
```go
var _ = Describe("AlertScale Controller", func() {
    var (
        ctx        context.Context
        cancel     context.CancelFunc
        k8sClient  client.Client
        testEnv    *envtest.Environment
    )

    BeforeEach(func() {
        ctx, cancel = context.WithCancel(context.Background())
        // Setup test environment
    })

    AfterEach(func() {
        cancel()
        // Cleanup
    })

    Describe("Reconciling AlertScale", func() {
        Context("when AlertScale is created", func() {
            It("should update status to pending", func() {
                // Test implementation
                Expect(alertScale.Status.State).To(Equal("pending"))
            })

            It("should send notification", func() {
                // Test notification behavior
                Eventually(func() bool {
                    // Check notification was sent
                    return true
                }).Should(BeTrue())
            })
        })

        Context("when auto-approval is enabled", func() {
            BeforeEach(func() {
                alertScale.Spec.ScaleAutoApproval = true
            })

            It("should transition to approved state", func() {
                // Test auto-approval logic
            })
        })
    })
})
```

### Test Categories
1. **Unit Tests**: Test individual functions and methods
2. **Integration Tests**: Test controller reconciliation with fake clients
3. **Webhook Tests**: Test admission webhook validation logic
4. **API Tests**: Test REST API endpoints
5. **E2E Tests**: Test complete workflows in real cluster

### Test Coverage Requirements
- **New Features**: 100% test coverage required
- **Bug Fixes**: Add regression tests
- **Edge Cases**: Test error conditions and timeouts
- **Mock Objects**: Use fake clients for unit tests
- **Real Cluster**: Use envtest for integration tests

## 🔄 Development Workflow

### Adding New Custom Resource (Kubebuilder)
1. **Scaffold API and Controller**:
   ```bash
   kubebuilder create api --group ops --version v1beta1 --kind PodRebalance --resource --controller
   ```
2. **Define CRD Types**: Edit `api/v1beta1/podrebalance_types.go`
   - Add Spec and Status structures
   - Include kubebuilder validation markers
   - Add print column markers for kubectl output
3. **Generate Manifests**: Run `make manifests generate`
   - Generates CRD YAML in `config/crd/bases/`
   - Generates deepcopy methods
   - Updates RBAC manifests
4. **Implement Controller**: Edit `internal/controller/podrebalance_controller.go`
   - Implement Reconcile function with idempotent logic
   - Add RBAC markers for required permissions
   - Handle finalizers and status updates
5. **Add Webhook (Optional)**: 
   ```bash
   kubebuilder create webhook --group ops --version v1beta1 --kind PodRebalance --defaulting --programmatic-validation
   ```
6. **Write Comprehensive Tests**: Create Ginkgo test suites
   - Unit tests for reconcile logic
   - Integration tests with envtest
   - Test all state transitions and error cases
7. **Update Documentation**: Add to `docs/api/`
8. **Verify Implementation**: Run `make test lint`

### Adding API Endpoint
1. **Define Handler**: Create in `internal/server/handlers/`
2. **Register Route**: Add to server router
3. **Add Validation**: Validate input parameters
4. **Error Handling**: Implement proper error responses
5. **Write Tests**: Create Ginkgo tests
6. **Document**: Add to `docs/api/`
7. **Verify**: Run `make test lint`

### Adding State Handler
1. **Implement Handler**: Add to `internal/handler/`
2. **Update State Machine**: Register new state
3. **Add Transitions**: Define valid state transitions
4. **Write Tests**: Test all state transitions
5. **Document**: Update state machine docs
6. **Verify**: Run `make test lint`

### Kubebuilder Project Maintenance
```bash
# Initialize new project (only once)
kubebuilder init --domain udesk.cn --repo udesk.cn/ops

# Update dependencies
go mod tidy

# Regenerate manifests after marker changes
make manifests

# Regenerate code after type changes  
make generate

# Full regeneration (equivalent to both above)
make manifests generate
```

## 🛠️ Development Commands

### Daily Development Workflow (Kubebuilder)
```bash
# Complete development cycle (MANDATORY for every change)
make manifests generate fmt vet test lint

# Individual commands
make manifests          # Generate CRD manifests
make generate          # Generate deepcopy methods
make fmt               # Format Go code
make vet               # Run go vet
make test              # Run all tests (REQUIRED)
make lint              # Run golangci-lint (REQUIRED)
```

### Local Development
```bash
# Run operator locally (without webhooks)
make run

# Run with webhooks (requires cert-manager)
make run-webhooks

# Install CRDs to cluster
make install

# Deploy complete operator
make deploy

# Undeploy
make undeploy
```

### Testing Commands
```bash
# Run all tests
make test

# Run specific package tests
go test ./internal/controller/... -v

# Run tests with coverage
go test -coverprofile=coverage.out ./...

# View coverage report
go tool cover -html=coverage.out
```

## 📋 Quality Assurance Checklist

Before ANY pull request or commit, verify:

### Testing Requirements
- [ ] New functionality has comprehensive Ginkgo tests
- [ ] All existing tests continue to pass
- [ ] Edge cases and error conditions are tested
- [ ] `make test` returns 0 exit code

### Code Quality Requirements
- [ ] `make lint` returns 0 issues
- [ ] Code follows Go conventions
- [ ] Error handling is implemented
- [ ] Logging is added for observability
- [ ] Context cancellation is handled

### Documentation Requirements
- [ ] New features documented in `docs/`
- [ ] API changes documented
- [ ] Configuration options explained
- [ ] Examples provided

### Kubernetes Requirements
- [ ] RBAC permissions updated if needed
- [ ] CRD validation schemas updated
- [ ] Status reporting implemented
- [ ] Finalizers added for cleanup

## 🎯 Common Implementation Patterns

### Kubebuilder Controller Setup Pattern
```go
// main.go - Kubebuilder generated manager setup
func main() {
    var metricsAddr string
    var enableLeaderElection bool
    var probeAddr string
    
    flag.StringVar(&metricsAddr, "metrics-bind-address", ":8080", "The address the metric endpoint binds to.")
    flag.StringVar(&probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
    flag.BoolVar(&enableLeaderElection, "leader-elect", false, "Enable leader election for controller manager.")
    flag.Parse()

    mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
        Scheme:                 scheme,
        MetricsBindAddress:     metricsAddr,
        Port:                   9443,
        HealthProbeBindAddress: probeAddr,
        LeaderElection:         enableLeaderElection,
        LeaderElectionID:       "f1c5ece8.udesk.cn",
    })
    if err != nil {
        setupLog.Error(err, "unable to start manager")
        os.Exit(1)
    }

    // Register controllers
    if err = (&controller.AlertScaleReconciler{
        Client: mgr.GetClient(),
        Scheme: mgr.GetScheme(),
    }).SetupWithManager(mgr); err != nil {
        setupLog.Error(err, "unable to create controller", "controller", "AlertScale")
        os.Exit(1)
    }
    
    // Setup webhooks
    if err = (&opsv1beta1.AlertScale{}).SetupWebhookWithManager(mgr); err != nil {
        setupLog.Error(err, "unable to create webhook", "webhook", "AlertScale")
        os.Exit(1)
    }
}
```

### Kubebuilder CRD Type Definition Pattern
```go
// api/v1beta1/alertscale_types.go
package v1beta1

import (
    metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// EDIT THIS FILE!  This is scaffolding for you to own.
// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.

// AlertScaleSpec defines the desired state of AlertScale
type AlertScaleSpec struct {
    // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
    // Important: Run "make" to regenerate code after modifying this file

    // +kubebuilder:validation:Required
    // +kubebuilder:validation:Minimum=1
    // +kubebuilder:validation:Maximum=1000
    Replicas int32 `json:"replicas"`

    // +kubebuilder:validation:Optional
    // +kubebuilder:default:=false
    AutoApproval bool `json:"autoApproval,omitempty"`

    // +kubebuilder:validation:Optional
    // +kubebuilder:default:="30m"
    // +kubebuilder:validation:Pattern=`^[0-9]+(s|m|h)$`
    Timeout string `json:"timeout,omitempty"`
}

// AlertScaleStatus defines the observed state of AlertScale
type AlertScaleStatus struct {
    // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
    // Important: Run "make" to regenerate code after modifying this file
    
    // +optional
    Phase string `json:"phase,omitempty"`
    
    // +optional
    Message string `json:"message,omitempty"`
    
    // +optional
    Conditions []metav1.Condition `json:"conditions,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Namespaced,shortName=as
// +kubebuilder:printcolumn:name="Phase",type="string",JSONPath=".status.phase"
// +kubebuilder:printcolumn:name="Replicas",type="integer",JSONPath=".spec.replicas"
// +kubebuilder:printcolumn:name="Auto-Approval",type="boolean",JSONPath=".spec.autoApproval"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"

// AlertScale is the Schema for the alertscales API
type AlertScale struct {
    metav1.TypeMeta   `json:",inline"`
    metav1.ObjectMeta `json:"metadata,omitempty"`

    Spec   AlertScaleSpec   `json:"spec,omitempty"`
    Status AlertScaleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AlertScaleList contains a list of AlertScale
type AlertScaleList struct {
    metav1.TypeMeta `json:",inline"`
    metav1.ListMeta `json:"metadata,omitempty"`
    Items           []AlertScale `json:"items"`
}

func init() {
    SchemeBuilder.Register(&AlertScale{}, &AlertScaleList{})
}
```

### Kubebuilder Controller Implementation Pattern
```go
// internal/controller/alertscale_controller.go
package controller

import (
    "context"
    "time"

    apierrors "k8s.io/apimachinery/pkg/api/errors"
    "k8s.io/apimachinery/pkg/runtime"
    ctrl "sigs.k8s.io/controller-runtime"
    "sigs.k8s.io/controller-runtime/pkg/client"
    "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
    "sigs.k8s.io/controller-runtime/pkg/log"

    opsv1beta1 "udesk.cn/ops/api/v1beta1"
)

// AlertScaleReconciler reconciles a AlertScale object
type AlertScaleReconciler struct {
    client.Client
    Scheme *runtime.Scheme
}

const (
    AlertScaleFinalizer = "alertscale.ops.udesk.cn/finalizer"
)

// +kubebuilder:rbac:groups=ops.udesk.cn,resources=alertscales,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=ops.udesk.cn,resources=alertscales/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=ops.udesk.cn,resources=alertscales/finalizers,verbs=update
// +kubebuilder:rbac:groups=apps,resources=deployments,verbs=get;list;watch;update;patch
// +kubebuilder:rbac:groups="",resources=events,verbs=create;patch

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *AlertScaleReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    log := log.FromContext(ctx)

    // Fetch the AlertScale instance
    var alertScale opsv1beta1.AlertScale
    if err := r.Get(ctx, req.NamespacedName, &alertScale); err != nil {
        if apierrors.IsNotFound(err) {
            // Request object not found, could have been deleted after reconcile request.
            return ctrl.Result{}, nil
        }
        log.Error(err, "unable to fetch AlertScale")
        return ctrl.Result{}, err
    }

    // Handle deletion
    if alertScale.DeletionTimestamp != nil {
        return r.handleDeletion(ctx, &alertScale)
    }

    // Add finalizer if not present
    if !controllerutil.ContainsFinalizer(&alertScale, AlertScaleFinalizer) {
        controllerutil.AddFinalizer(&alertScale, AlertScaleFinalizer)
        if err := r.Update(ctx, &alertScale); err != nil {
            return ctrl.Result{}, err
        }
        return ctrl.Result{Requeue: true}, nil
    }

    // Main reconciliation logic
    return r.reconcileNormal(ctx, &alertScale)
}

// SetupWithManager sets up the controller with the Manager.
func (r *AlertScaleReconciler) SetupWithManager(mgr ctrl.Manager) error {
    return ctrl.NewControllerManagedBy(mgr).
        For(&opsv1beta1.AlertScale{}).
        Complete(r)
}
```

### Kubebuilder Webhook Implementation Pattern
```go
// api/v1beta1/alertscale_webhook.go
package v1beta1

import (
    "context"
    "fmt"

    "k8s.io/apimachinery/pkg/runtime"
    ctrl "sigs.k8s.io/controller-runtime"
    logf "sigs.k8s.io/controller-runtime/pkg/log"
    "sigs.k8s.io/controller-runtime/pkg/webhook"
    "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// log is for logging in this package.
var alertscalelog = logf.Log.WithName("alertscale-resource")

// SetupWebhookWithManager will setup the manager to manage the webhooks
func (r *AlertScale) SetupWebhookWithManager(mgr ctrl.Manager) error {
    return ctrl.NewWebhookManagedBy(mgr).
        For(r).
        Complete()
}

// +kubebuilder:webhook:path=/mutate-ops-udesk-cn-v1beta1-alertscale,mutating=true,failurePolicy=fail,sideEffects=None,groups=ops.udesk.cn,resources=alertscales,verbs=create;update,versions=v1beta1,name=malertscale.kb.io,admissionReviewVersions=v1

var _ webhook.Defaulter = &AlertScale{}

// Default implements webhook.Defaulter so a webhook will be registered for the type
func (r *AlertScale) Default() {
    alertscalelog.Info("default", "name", r.Name)

    if r.Spec.Timeout == "" {
        r.Spec.Timeout = "30m"
    }
}

// +kubebuilder:webhook:path=/validate-ops-udesk-cn-v1beta1-alertscale,mutating=false,failurePolicy=fail,sideEffects=None,groups=ops.udesk.cn,resources=alertscales,verbs=create;update,versions=v1beta1,name=valertscale.kb.io,admissionReviewVersions=v1

var _ webhook.Validator = &AlertScale{}

// ValidateCreate implements webhook.Validator so a webhook will be registered for the type
func (r *AlertScale) ValidateCreate() (admission.Warnings, error) {
    alertscalelog.Info("validate create", "name", r.Name)
    return nil, r.validateAlertScale()
}

// ValidateUpdate implements webhook.Validator so a webhook will be registered for the type
func (r *AlertScale) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
    alertscalelog.Info("validate update", "name", r.Name)
    return nil, r.validateAlertScale()
}

// ValidateDelete implements webhook.Validator so a webhook will be registered for the type
func (r *AlertScale) ValidateDelete() (admission.Warnings, error) {
    alertscalelog.Info("validate delete", "name", r.Name)
    return nil, nil
}

func (r *AlertScale) validateAlertScale() error {
    if r.Spec.Replicas < 1 || r.Spec.Replicas > 1000 {
        return fmt.Errorf("replicas must be between 1 and 1000")
    }
    return nil
}
```

### Controller Reconcile Pattern
```go
func (r *AlertScaleReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    log := r.Log.WithValues("alertscale", req.NamespacedName)
    
    // Fetch the AlertScale instance
    alertScale := &opsv1beta1.AlertScale{}
    if err := r.Get(ctx, req.NamespacedName, alertScale); err != nil {
        if errors.IsNotFound(err) {
            return ctrl.Result{}, nil
        }
        return ctrl.Result{}, err
    }
    
    // Handle deletion
    if alertScale.DeletionTimestamp != nil {
        return r.handleDeletion(ctx, alertScale)
    }
    
    // Add finalizer if needed
    if !controllerutil.ContainsFinalizer(alertScale, AlertScaleFinalizer) {
        controllerutil.AddFinalizer(alertScale, AlertScaleFinalizer)
        return ctrl.Result{}, r.Update(ctx, alertScale)
    }
    
    // Main reconciliation logic
    return r.reconcileNormal(ctx, alertScale)
}
```

### API Handler Pattern
```go
func (h *AlertScaleHandler) HandleCreate(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // Parse request
    var req CreateAlertScaleRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        http.Error(w, "Invalid request body", http.StatusBadRequest)
        return
    }
    
    // Validate request
    if err := h.validateCreateRequest(&req); err != nil {
        http.Error(w, err.Error(), http.StatusBadRequest)
        return
    }
    
    // Create resource
    alertScale, err := h.createAlertScale(ctx, &req)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    
    // Return response
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusCreated)
    json.NewEncoder(w).Encode(alertScale)
}
```

### State Handler Pattern
```go
func (h *PendingStateHandler) Handle(ctx *types.ScaleContext) (ctrl.Result, error) {
    log := ctrl.LoggerFrom(ctx.Context).WithName("pending-handler")
    
    // Validate state transition
    if !h.CanTransition(ctx.AlertScale.Status.State) {
        return ctrl.Result{}, fmt.Errorf("invalid state transition")
    }
    
    // Execute state logic
    if err := h.executeStateBehavior(ctx); err != nil {
        return ctrl.Result{}, err
    }
    
    // Update status
    return h.updateStatus(ctx, "processing")
}
```

## 🚀 Performance and Scalability

### Resource Management
- Use resource limits and requests
- Implement graceful shutdown
- Handle high-volume events efficiently
- Use work queues for async processing

### Monitoring and Observability
- Add Prometheus metrics
- Implement health checks
- Use structured logging
- Add distributed tracing

### Security Considerations
- Follow principle of least privilege
- Validate all inputs
- Secure API endpoints
- Use service accounts properly

---

## 🎯 Success Criteria

A feature is considered complete ONLY when:
1. ✅ Comprehensive Ginkgo tests are written and passing
2. ✅ `make test` returns zero failures
3. ✅ `make lint` returns zero issues
4. ✅ Documentation is updated in `docs/`
5. ✅ Code follows all established patterns
6. ✅ RBAC permissions are properly configured

**Remember**: This is a production Kubernetes operator. Quality, reliability, and maintainability are paramount. Never compromise on testing or code quality for speed of delivery.
- **CRDs**: AlertScale, ScaleNotifyConfig, ScaleNotifyMsgTemplate

## Mandatory Requirements

### Code Quality Gates
Before any code changes are considered complete, you MUST:

1. **Execute Tests**: Run `make test` and ensure all tests pass
2. **Execute Linting**: Run `make lint` and fix all issues
3. **No Exceptions**: Both commands must succeed with zero errors

### Documentation Standards
- **All documentation** goes in the `docs/` directory
- **Project overview** is maintained in `README.md` (root level)
- **API documentation** should be in `docs/api/`
- **Development guides** should be in `docs/development/`
- **Deployment guides** should be in `docs/deployment/`

### Testing Framework
- **Framework**: Ginkgo v2 BDD testing only
- **No standard Go testing**: All tests must use Ginkgo
- **Structure**: Each package has `*_suite_test.go` and `*_test.go` files
- **Coverage**: Maintain meaningful test coverage for all packages

## Project Structure

```
udesk-ops-operator/
├── api/v1beta1/              # CRD definitions
├── cmd/                      # Main application entry point
├── config/                   # Kubernetes manifests and configuration
├── docs/                     # ALL documentation files
├── hack/                     # Build scripts and utilities
├── internal/
│   ├── controller/           # Kubernetes controllers
│   ├── handler/              # State handlers for AlertScale
│   ├── server/               # REST API server
│   │   └── handlers/         # API endpoint handlers
│   ├── strategy/             # Scaling strategies
│   ├── types/                # Internal type definitions
│   └── webhook/              # Admission webhooks
├── test/                     # Integration and e2e tests
└── README.md                 # Project overview
```

## Development Guidelines

### Code Standards
- **Go Modules**: Use Go 1.21+ with proper module management
- **Imports**: Group imports (std, 3rd party, internal)
- **Error Handling**: Always handle errors appropriately
- **Logging**: Use controller-runtime logging (logr)
- **Context**: Pass context.Context for cancellation
- **Resource Management**: Properly handle Kubernetes client resources

### Kubernetes Operator Best Practices
- **Reconciliation**: Implement idempotent reconcile loops
- **Status Updates**: Use separate status client for status updates
- **Finalizers**: Implement proper cleanup with finalizers
- **RBAC**: Define minimal required permissions
- **Validation**: Use admission webhooks for validation
- **Observability**: Add metrics and health checks

### API Design Principles
- **REST**: Follow RESTful conventions
- **Versioning**: Use `/api/v1/` prefix
- **Error Handling**: Return consistent error responses
- **Authentication**: Consider authentication for production
- **Documentation**: Maintain OpenAPI/Swagger docs

### Testing Approach
- **Unit Tests**: Test individual functions and methods
- **Integration Tests**: Test controller reconciliation
- **E2E Tests**: Test complete workflows
- **BDD Style**: Use descriptive Ginkgo specs
- **Mocking**: Use fake clients for unit tests

## Common Tasks

### Adding New CRD
1. Define types in `api/v1beta1/`
2. Add controller in `internal/controller/`
3. Generate manifests: `make manifests`
4. Create Ginkgo tests
5. Update RBAC permissions
6. Document in `docs/api/`

### Adding API Endpoint
1. Create handler in `internal/server/handlers/`
2. Register in handler's `init()` function
3. Add validation and error handling
4. Create Ginkgo tests
5. Document endpoint in `docs/api/`

### Adding State Handler
1. Implement handler in `internal/handler/`
2. Add to state machine registration
3. Create comprehensive Ginkgo tests
4. Document state transitions

## Code Examples

### Ginkgo Test Structure
```go
var _ = Describe("ComponentName", func() {
    var (
        ctx        context.Context
        fakeClient client.Client
    )

    BeforeEach(func() {
        ctx = context.Background()
        fakeClient = fake.NewClientBuilder().Build()
    })

    Describe("MethodName", func() {
        Context("when condition is met", func() {
            It("should perform expected behavior", func() {
                // Test implementation
                Expect(result).To(Succeed())
            })
        })
    })
})
```

### Error Handling Pattern
```go
if err != nil {
    log.Error(err, "Failed to perform operation")
    return ctrl.Result{}, err
}
```

### Status Update Pattern
```go
// Update status separately from spec
alertScale.Status.ScaleStatus.Status = newStatus
if err := r.Status().Update(ctx, &alertScale); err != nil {
    return ctrl.Result{}, err
}
```

## Build and Development Commands

```bash
# Development workflow
make manifests generate fmt vet test lint

# Run locally
make run-without-webhook

# Build binary
make build

# Docker operations
make docker-build docker-push

# Deploy to cluster
make deploy

# Run e2e tests
make test-e2e
```

## Quality Assurance Checklist

Before considering any feature complete:
- [ ] All new code has Ginkgo tests
- [ ] `make test` passes (100% success rate required)
- [ ] `make lint` passes (0 issues required)
- [ ] Documentation updated in `docs/`
- [ ] RBAC permissions updated if needed
- [ ] Error handling implemented
- [ ] Logging added for observability
- [ ] Status updates use proper patterns

## Documentation Requirements

### API Documentation
- Endpoint descriptions
- Request/response schemas
- Error codes and meanings
- Authentication requirements
- Usage examples

### Developer Documentation
- Architecture overview
- State machine diagrams
- Database/storage patterns
- Configuration options
- Troubleshooting guides

### Deployment Documentation
- Installation instructions
- Configuration examples
- Monitoring setup
- Backup/restore procedures
- Upgrade procedures

## Common Patterns to Follow

### Controller Pattern
- Implement `Reconcile(ctx context.Context, req ctrl.Request)`
- Handle not found errors gracefully
- Use exponential backoff for retries
- Implement proper status reporting

### API Handler Pattern
- Validate input parameters
- Use proper HTTP status codes
- Return consistent JSON responses
- Log all operations
- Handle context cancellation

### State Handler Pattern
- Implement `Handle(ctx *types.ScaleContext) (ctrl.Result, error)`
- Use declarative state transitions
- Avoid direct status field conflicts
- Implement timeout handling

Remember: This is a production Kubernetes operator. All code must be robust, well-tested, and follow cloud-native best practices. Always prioritize reliability and observability over feature velocity.

---

## 📚 Kubebuilder Command Reference

### Project Initialization
```bash
# Initialize a new Kubebuilder project
kubebuilder init --domain udesk.cn --repo udesk.cn/ops

# Initialize with specific plugins
kubebuilder init --domain udesk.cn --repo udesk.cn/ops --plugins go/v4

# Check Kubebuilder version
kubebuilder version
```

### API and Controller Generation
```bash
# Create new API with controller
kubebuilder create api --group ops --version v1beta1 --kind AlertScale --resource --controller

# Create API only (no controller)
kubebuilder create api --group ops --version v1beta1 --kind AlertScale --resource

# Create controller only (no API)
kubebuilder create api --group ops --version v1beta1 --kind AlertScale --controller
```

### Webhook Generation
```bash
# Create admission webhook with defaulting and validation
kubebuilder create webhook --group ops --version v1beta1 --kind AlertScale --defaulting --programmatic-validation

# Create conversion webhook for API versioning
kubebuilder create webhook --group ops --version v1beta1 --kind AlertScale --conversion
```

### Code and Manifest Generation
```bash
# Generate all manifests (CRDs, RBAC, etc.)
make manifests

# Generate deep copy and other boilerplate code
make generate

# Both generation commands
make manifests generate

# Manual controller-gen usage
bin/controller-gen rbac:roleName=manager-role crd webhook paths="./..." output:crd:artifacts:config=config/crd/bases

# Generate deepcopy methods
bin/controller-gen object:headerFile="hack/boilerplate.go.txt" paths="./..."
```

### Testing and Development
```bash
# Install CRDs to current cluster
make install

# Uninstall CRDs from current cluster
make uninstall

# Run operator locally (without webhooks)
make run

# Run tests using envtest
make test

# Build operator binary
make build

# Build and push Docker image
make docker-build docker-push IMG=<registry>/<image>:<tag>

# Deploy operator to cluster
make deploy IMG=<registry>/<image>:<tag>

# Undeploy operator from cluster
make undeploy
```

### Certificate Management for Webhooks
```bash
# Install cert-manager (required for webhooks in cluster)
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml

# Generate certificates for local webhook development
make run-webhook-dev
```

### Customization and Configuration
```bash
# Edit Kustomization files for different environments
# config/default/kustomization.yaml - default deployment
# config/development/kustomization.yaml - development settings
# config/production/kustomization.yaml - production settings

# Generate deployment manifests for specific environment
kustomize build config/default

# Apply manifests with kustomize
kustomize build config/default | kubectl apply -f -
```

### Project Structure Commands
```bash
# View project configuration
cat PROJECT

# Check generated files
ls -la config/crd/bases/
ls -la config/rbac/
ls -la api/v1beta1/zz_generated.*

# Verify generated RBAC
cat config/rbac/role.yaml
```

### Debugging and Troubleshooting
```bash
# Check CRD installation
kubectl get crd

# View CRD definition
kubectl describe crd alertscales.ops.udesk.cn

# Check operator logs when deployed
kubectl logs -n system deployment/controller-manager

# Port forward for webhook debugging
kubectl port-forward -n system svc/webhook-service 9443:443

# Validate webhook certificates
kubectl get certificates -n system
kubectl describe certificate serving-cert -n system
```

### Best Practices Commands
```bash
# Always run full verification before commit
make manifests generate fmt vet test lint

# Check for security issues
gosec ./...

# Run comprehensive tests
go test -race -coverprofile=coverage.out ./...

# View test coverage
go tool cover -html=coverage.out -o coverage.html
```
